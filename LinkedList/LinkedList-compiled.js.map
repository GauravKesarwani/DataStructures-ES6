{"version":3,"sources":["LinkedList.es6"],"names":[],"mappings":"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","file":"LinkedList-compiled.js","sourcesContent":["'use strict';\n\n// class construct. More clean code. Looks more like java.\nclass Node {\n  constructor(data) {\n    this._data = data;\n    this._next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.first = new Node(\"av\");\n    this.second = new Node(\"c\");\n    this.third = new Node(\"d\");\n    this.fourth = new Node(\"c\");\n    this.fifth = new Node(\"ba\");\n    this.first._next = this.second;\n    this.second._next = this.third;\n    this.third._next = this.fourth;\n    this.fourth._next = this.fifth;\n    this._head = this.first;\n  };\n\n  /* Print a new Link List */\n  printList() {\n    console.log('....printing list....');\n\n    let n = this._head;\n    console.log('value of n is ', n);\n    while (n != null) {\n      console.log(n._data);\n      n = n._next;\n    }\n  };\n\n  /* Linked List Insertion */\n\n  /* Insert a node at front of link list */\n\n  insertAtBeginning(data) {\n    let node = new Node(data);\n    node._next = this._head;\n    this._head = node;\n  };\n\n  /*\n  * Insert a node after a given node. Assume index starts at 0\n  *\n  *  If counting starts at 1 i.e nth node then (i < index - 1)\n  *\n  *  Given the nth node or given the pointer of nth node.\n  *\n  * */\n\n  insertAfterANode(data, index) {\n    let node = new Node(data),\n      current = this._head;\n    for (let i=0; i < index ; i++) {\n      if (current == null) {\n        console.log('Invalid Index');\n        return;\n      }\n      current = current._next;\n    }\n\n    node._next = current._next;\n    current._next = node;\n  };\n\n  /* Insert a node at end of link list */\n\n  insertAtEnd(data) {\n    let current = this._head,\n      node = new Node(data);\n\n    // Consider the case when list is empty.\n    if (this._head == null) {\n      this._head = new Node(data);\n      return;\n    }\n\n    while(current._next != null) {\n      current = current._next;\n    }\n\n    current._next = node;\n  };\n\n  /*\n  *  Deletion in a linked list - Scenarios\n  *   1. Delete the first element\n  *   2. Delete the last element\n  *   3. Delete an element in the middle of link list at a given position\n  *   4. Delete an element with given key\n  *\n  * */\n\n  deleteKey(data) {\n    let current = this._head,\n      prev = null;\n\n    //if node to be deleted is the first node.\n\n    if (current != null && current._data === data) {\n      this._head = current._next;\n      console.log('Deleted the node with key ', data);\n      return;\n    }\n\n    while(current._data != data) {\n      prev = current;\n      current = current._next;\n    }\n\n    // if key is not present in linked list\n    if (current === null) {\n      return;\n    }\n\n    prev._next = current._next;\n    console.log('Deleted the node with key ', data);\n    return;\n  };\n\n  /* Can be done using only one temporary variable. See geek for geeks.*/\n  deleteNodeAtIndex(index) {\n    let i = 0,\n      current = this._head,\n      prev = null;\n\n    if (current == null) {\n      console.log('Invalid request..! List is empty..!')\n      return;\n    }\n\n    //if head needs to be removed\n    if (i==0) {\n      this._head = current._next;\n    }\n\n    while(i < index) {\n      prev = current;\n      current = current._next;\n      i++;\n    }\n    if(current == null) {\n      console.log('Position is greater than number of nodes to be deleted');\n      return;\n    }\n    prev._next = current._next;\n  };\n\n  binaryToDecimal() {\n    let binaryString = '',\n      current = this._head;\n    while(current != null) {\n      binaryString = binaryString + current._data;\n      current = current._next;\n    }\n   return parseInt(binaryString, 2);\n\n  };\n\n  checkIfPallindrome(dataString) {\n    let stringLength = dataString.length;\n    for (let i = 0; i < stringLength; i++) {\n      if (dataString.charAt(i) !== dataString.charAt(stringLength - i - 1)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  isLinkListPallindrome() {\n    let current = this._head,\n      dataString='';\n    while(current != null) {\n      dataString+= current._data;\n      current = current._next;\n    }\n\n    return this.checkIfPallindrome(dataString);\n\n  }\n}\nlet linkedList = new LinkedList();\n  \nconsole.log(linkedList.isLinkListPallindrome());\n"]}